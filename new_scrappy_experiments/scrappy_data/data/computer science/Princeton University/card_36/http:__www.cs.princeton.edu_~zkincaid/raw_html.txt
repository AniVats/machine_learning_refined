"<html xmlns=\"http://www.w3.org/1999/xhtml\"><head>\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n  <title>Zak Kincaid</title>\n  <link href=\"http://fonts.googleapis.com/css?family=PT+Sans\" rel=\"stylesheet\" type=\"text/css\">\n  <link href=\"https://fonts.googleapis.com/css?family=Fjalla+One\" rel=\"stylesheet\"> \n  <link href=\"http://fonts.googleapis.com/css?family=Oswald\" rel=\"stylesheet\" type=\"text/css\">\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\">\n </head>\n <body>\n   <div class=\"main\">\n   <table style=\"margin-left:auto; margin-right:auto\">\n    <tbody><tr>\n     <td><img src=\"img/zak.jpg\" width=\"250\" alt=\"Zachary Kincaid\"></td>\n     <td style=\"padding-left:30px\">\n      <span class=\"name\">Zak Kincaid</span>\n\n      <br><br>\n      I'm an assistant professor at <a href=\"http://www.cs.princeton.edu/\">Princeton University</a>.<br>\n      My main research interests are in program analysis and programming languages.<br>\n      Email: <a href=\"mailto:zkincaid@cs.princeton.edu\">zkincaid@cs.princeton.edu</a><br>\n      Office: Computer Science Building, Room 219<br>\n      Address: 35 Olden Street, Princeton, NJ 08540<br><br>\n      <b>Office hours</b>: Tuesday 4-5pm.\n     </td>\n    </tr>\n   </tbody></table>\n\n   <div class=\"nav\">\n     <a class=\"nav\" href=\"#publications\">publications</a> |\n     <a class=\"nav\" href=\"#teaching\">teaching</a> |\n     <a class=\"nav\" href=\"#students\">students</a> |\n     <a class=\"nav\" href=\"#activities\">activities</a> |\n     <a class=\"nav\" href=\"#misc\">etc</a> |\n     <a class=\"nav\" href=\"https://github.com/zkincaid\">github</a>\n     | <a class=\"nav\" href=\"http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Kincaid:Zachary.html\">dblp</a>\n   </div>\n\n   <h1>news</h1>\n   <ul>\n     <li>\n       4/15: <i>Loop Summarization with Rational Vector Addition Systems</i>, with <a href=\"http://www.cs.princeton.edu/~jakers/\">Jake Silverman</a> to appear at <a href=\"http://i-cav.org/2019/\">CAV 2019</a>.\n     </li>\n     <li>\n       2/4: I'll be teaching <a href=\"http://www.cs.princeton.edu/courses/archive/spring19/cos320/\">COS 320: Compiling Techniques</a> this spring.\n     </li>\n     <li>\n       11/18: <i>A Practical Algorithm for Structure Embedding</i>, with <a href=\"http://www.cs.princeton.edu/~tcm3/\">Charlie Murphy</a> to appear at <a href=\"https://popl19.sigplan.org/track/VMCAI-2019\">VMCAI 2019</a>.\n     </li>\n     <li>\n       10/9: Two papers with Jason Breck, <a href=\"https://pages.cs.wisc.edu/~jcyphert/\">John Cyphert</a>, and <a href=\"http://pages.cs.wisc.edu/~reps/\">Tom Reps</a> to appear at <a href=\"https://popl19.sigplan.org/\">POPL'19</a>:\n       <ul>\n\t <li><i>Closed Forms for Numerical Loops</i></li>\n\t <li><i>Refinement of Path Expressions for Static Analysis</i></li>\n       </ul>\n     </li>\n     <li>\n       9/7: I'll be teaching <a href=\"courses/fall18/\">COS 516: Automated Reasoning about Software</a> this fall.\n     </li>\n\n     <li>\n       3/28: I'll be co-chairing colocated events for POPL'19 with <a href=\"http://www.acsu.buffalo.edu/~gaboardi/\">Marco Gaboardi</a>.\n     </li>\n     <li>\n       2/3: I'll be speaking at <a href=\"http://staticanalysis.org/sas2018/sas2018.html\">SAS'18</a> on numerical invariant generation.\n     </li>\n   </ul>\n\n   <h1><a name=\"publications\">selected publications</a> (full list at <a href=\"http://www.informatik.uni-trier.de/~ley/db/indices/a-tree/k/Kincaid:Zachary.html\">dblp</a>)</h1>\n\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Loop Summarization with Rational Vector Addition Systems</span>\n      with <a href=\"http://www.cs.princeton.edu/~jakers/\">Jake Silverman</a>. CAV 2019.\n      <div class=\"blurb\">\n\tThis paper presents a technique for computing numerical loop\n\tsummaries. The method synthesizes a rational vector addition\n\tsystem with resets (Q-VASR) that simulates the action of an\n\tinput loop, and then uses the reachability relation of that\n\tQ-VASR to over-approximate the behavior of the loop. The key\n\ttechnical problem solved in this paper is to automatically\n\tsynthesize a Q-VASR that is a best abstraction of a given loop\n\tin the sense that (1) it simulates the loop and (2) it is\n\tsimulated by any other Q-VASR that simulates the loop. Since\n\tour loop summarization scheme is based on computing the exact\n\treachability relation of a best abstraction of a loop, we can\n\tmake theoretical guarantees about its behavior. Moreover, we\n\tshow experimentally that the technique is precise and\n\tperformant in practice.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/cav19.pdf\">\n      <img src=\"img/cav19.png\" alt=\"CAV19 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">A Practical Algorithm for Structure\n\tEmbedding</span>\n      with <a href=\"http://www.cs.princeton.edu/~tcm3/\">Charlie\n\tMurphy</a>. VMCAI 2019.\n      <div class=\"blurb\">\n\tThis paper presents an algorithm for the <i>structure\n\tembedding problem</i>: given two finite first-order structures\n\tover a common relational vocabulary, does there exist an\n\tinjective homomorphism from one to the other? The structure\n\tembedding problem is NP-complete in the general case, but for\n\tmonadic structures (each predicate has arity at most 1) we\n\tobserve that it can be solved in polytime by reduction to\n\tbipartite graph matching. Our algorithm, MatchEmbeds, extends\n\tthe bipartite matching approach to the general case by using\n\tit as the foundation of a backtracking search procedure. We\n\tshow that MatchEmbeds outper- forms state-of-the-art SAT, CSP,\n\tand subgraph isomorphism solvers on difficult random instances\n\tand significantly improves the performance of a client model\n\tchecker for multi-threaded programs.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/vmcai19.pdf\">\n      <img src=\"img/vmcai19.png\" alt=\"VMCAI19 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Closed Forms for Numerical Loops</span>\n     with Jason Breck, <a href=\"https://pages.cs.wisc.edu/~jcyphert/\">John Cyphert</a>, and <a href=\"http://pages.cs.wisc.edu/~reps/\">Tom Reps</a>. POPL 2019.\n      <div class=\"blurb\">\n\tThis paper investigates the problem of reasoning about\n\tnon-linear behavior of simple numerical loops. Our approach\n\tbuilds on classical techniques for analyzing the behavior of\n\tlinear dynamical systems. It is well-known that a closed-form\n\trepresentation of the behavior of a linear dynamical system\n\tcan always be expressed using algebraic numbers, but this\n\tapproach can create formulas that present an obstacle for\n\tautomated-reasoning tools. This paper characterizes when\n\tlinear loops have closed forms in simpler theories that are\n\tmore amenable to automated reasoning. The algorithms for\n\tcomputing closed forms described in the paper avoid the use of\n\talgebraic numbers, and produce closed forms expressed using\n\tpolynomials and exponentials over rational numbers. We show\n\tthat the logic for expressing closed forms is decidable,\n\tyielding decision procedures for verifying safety and\n\ttermination of a class of numerical loops over rational\n\tnumbers. We also show that the procedure for computing closed\n\tforms for this class of numerical loops can be usedxc to\n\tover-approximate the behavior of arbitrary numerical programs\n\t(with unrestricted control flow, non-deterministic\n\tassignments, and recursive procedures).\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl19a.pdf\">\n      <img src=\"img/popl19a.png\" alt=\"POPL19a PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl19a-slides.pdf\">\n      <img src=\"img/popl19a-slides.png\" alt=\"POPL19a Slides\"><br>\n      Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Refinement of Path Expressions for Static Analysis</span>\n     with <a href=\"https://pages.cs.wisc.edu/~jcyphert/\">John Cyphert</a>, Jason Breck, and <a href=\"http://pages.cs.wisc.edu/~reps/\">Tom Reps</a>. POPL 2019.\n      <div class=\"blurb\">\n\tAlgebraic program analyses compute information about a\n\tprogram's behavior by first (a) computing a valid path\n\texpression and then (b) interpreting the path expression in a\n\tsemantic algebra that defines the analysis. There are an\n\tinfinite number of different regular expressions that qualify\n\tas valid path expressions, which raises the question: <em>which\n\tone should we choose?</em> While any choice yields a sound result,\n\tfor many analyses the choice can have a drastic effect on the\n\tprecision of the results obtained. \n\tIn this paper, we develop an algorithm that takes as input a\n\tvalid path expression E, and returns a valid path expression E'\n\tthat is guaranteed to yield analysis results that are at\n\tleast as good as those obtained using E. \n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl19b.pdf\">\n      <img src=\"img/popl19b.png\" alt=\"POPL19b PDF\"><br>\n      PDF\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Numerical Invariants via Abstract Machines</span>.  Invited talk at SAS 2018.\n      <div class=\"blurb\">\n\tThis talk presents an overview of a line of recent work on\n\tgenerating non-linear numerical invariants for loops and\n\trecursive procedures. The method is compositional in the sense\n\tthat it operates by breaking the program into parts, analyzing\n\teach part independently, and then combining the results. The\n\tfundamental challenge is to devise an effective method for\n\tanalyzing the behavior of a loop given the results of\n\tanalyzing its body. The key idea is to separate the problem\n\tinto two: first we approximate the loop dynamics by an\n\tabstract machine, and then symbolically compute the\n\treachability relation of the abstract machine.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/sas18.pdf\">\n      <img src=\"img/sas18.png\" alt=\"SAS18 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/sas18-slides.pdf\">\n      <img src=\"img/sas18-slides.png\" alt=\"SAS18 Slides\"><br>\n      Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Non-Linear Reasoning For Invariant Synthesis</span>\n     with Jason Breck, <a href=\"https://pages.cs.wisc.edu/~jcyphert/\">John Cyphert</a>, and <a href=\"http://pages.cs.wisc.edu/~reps/\">Tom Reps</a>. POPL 2018.\n      <div class=\"blurb\">\n\tAn appealing approach to non-linear invariant generation is to exploit\n\tthe powerful recurrence-solving techniques that have been developed in\n\tthe field of computer algebra.  However, there is a gap between the\n\tcapabilities of recurrence solvers and the needs of program analysis:\n\t(1) loop bodies are not merely systems of recurrence relations---they\n\tmay contain conditional branches, nested loops, non-deterministic\n\tassignments, etc., and (2) a client program analyzer must be able to\n\treason about the closed-form solutions produced by a recurrence solver\n\t(e.g., to prove assertions).  This paper presents a method for\n\tgenerating non-linear invariants for general loops by analyzing\n\trecurrence relations.  The key components are an abstract domain for\n\treasoning about non-linear arithmetic, a semantics-based method for\n\textracting recurrence relations from loop bodies, and a recurrence\n\tsolver that avoids closed forms that involve complex or irrational\n\tnumbers.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl18a.pdf\">\n      <img src=\"img/popl18a.png\" alt=\"POPL18a PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl18a-slides.pdf\">\n      <img src=\"img/popl18a-slides.png\" alt=\"POPL18a Slides\"><br>\n      Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Strategy Synthesis for Linear Arithmetic Games</span>\n     with <a href=\"http://www.cs.toronto.edu/~azadeh\">Azadeh Farzan</a>.  POPL 2018.\n      <div class=\"blurb\">\n\tThis paper studies the strategy synthesis problem for games defined\n\twithin the theory of linear rational arithmetic.  Two types of games\n\tare considered.  A <i>satisfiability game</i>, described by a\n\tquantified formula, is played by two players that take turns\n\tinstantiating quantifiers. The objective of each player is to prove\n\t(or disprove) satisfiability of the formula.  A <i>reachability\n\tgame</i>, described by a pair of formulas defining the legal moves of\n\teach player, is played by two players that take turns choosing\n\tpositions---rational vectors of some fixed dimension.  The objective\n\tof each player is to reach a position where the opposing player has no\n\tlegal moves (or to play the game forever).  We give a complete\n\talgorithm for synthesizing winning strategies for satisfiability games\n\tand a semi-algorithm for synthesizing winning strategies for\n\treachability games.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl18b.pdf\">\n      <img src=\"img/popl18b.png\" alt=\"POPL18b PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl18b-slides.pdf\">\n      <img src=\"img/popl18b-slides.png\" alt=\"POPL18b Slides\"><br>\n      Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">A Symbolic Decision Procedure for Symbolic Alternating Automata</span>\n     with <a href=\"http://pages.cs.wisc.edu/~loris/\">Loris D'Antoni</a>, and Fang Wang.  MFPS 2017.\n      <div class=\"blurb\">\n\tWe introduce Symbolic Alternating Finite Automata (s-AFA) as a\n\tsuccinct and decidable model for describing sets of finite sequences\n\tover arbitrary alphabets. Boolean operations over s-AFAs have linear\n\tcomplexity, which contrasts the quadratic cost of intersection and\n\tunion for non-alternating symbolic automata. Due to this succinctness,\n\temptiness and equivalence checking are PSpace-hard. We introduce an\n\talgorithm for checking the equivalence of two s-AFAs based on\n\tbisimulation up to congruence. This algorithm exploits the power of\n\tSAT solvers to efficiently search the state space of the s-AFAs.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/mfps17.pdf\">\n      <img src=\"img/mfps17.png\" alt=\"MFPS17 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Compositional Recurrence Analysis Revisited</span>\n     with Jason Breck, Ashkan Boroujeni, and <a href=\"http://pages.cs.wisc.edu/~reps/\">Tom Reps</a>.  PLDI 2017.\n      <div class=\"blurb\">\n\tCompositional recurrence analysis (CRA) is a static-analysis method\n\tbased on a combination of symbolic analysis and abstract\n\tinterpretation.  CRA computes the meaning of a procedure following\n\tTarjan\u2019s path-expression method: first compute a regular expression\n\trecognizing a set of paths through the procedure, then interpret that\n\tregular expression within a suitable semantic algebra.  This paper\n\tintroduces ICRA, an extension of CRA to recursive procedures.  ICRA\n\tovercomes the \u201cimpedance mismatch\u201d between CRA, which relies on\n\trepresenting program paths with regular languages, and the\n\tcontext-free-language underpinnings of context-sensitive analysis.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/pldi17.pdf\">\n      <img src=\"img/pldi17.png\" alt=\"PLDI17 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/pldi17-slides.pdf\">\n      <img src=\"img/pldi17-slides.png\" alt=\"PLDI17 Slides\"><br>\n      Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Linear Arithmetic Satisfiability via Strategy Improvement</span>\n     with <a href=\"http://www.cs.toronto.edu/~azadeh\">Azadeh Farzan</a>.  IJCAI 2016.\n      <div class=\"blurb\">\n\tThis article presents a decision procedure for the theory of linear\n\trational arithmetic (and linear integer arithmetic), including\n\tquantifiers.  The algorithm is based on synthesizing winning\n\tstrategies for quantified formulas (interpreted as satisfiability\n\tgames) by mutual strategy improvement.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/ijcai16.pdf\">\n      <img src=\"img/ijcai16.png\" alt=\"IJCAI16 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/ijcai16-slides.pdf\">\n      <img src=\"img/ijcai16-slides.png\" alt=\"IJCAI16 Slides\"><br>\n      Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Proving Liveness of Parameterized Programs </span>\n     with <a href=\"http://www.cs.toronto.edu/~azadeh\">Azadeh Farzan</a> and <a href=\"http://swt.informatik.uni-freiburg.de/staff/podelski\">Andreas Podelski</a>.\n     LICS 2016.\n      <div class=\"blurb\">\n\tCorrectness of multi-threaded programs typically requires that they\n\tsatisfy liveness properties. For example, a program may require that\n\tno thread is starved of a shared resource, or that all threads\n\teventually agree on a single value. This paper presents a method for\n\tproving that such liveness properties hold. Two particular challenges\n\taddressed in this work are that (1) the correctness argument may rely\n\ton global behaviour of the system (e.g., the correctness argument may\n\trequire that all threads collectively progress towards \"the good\n\tthing\" rather than one thread progressing while the others do not\n\tinterfere), and (2) such programs are often designed to be executed by\n\tany number of threads, and the desired liveness properties must hold\n\tregardless of the number of threads that are active in the program.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/lics16.pdf\">\n      <img src=\"img/lics16.png\" alt=\"LICS16 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/lics16-slides.pdf\">\n      <img src=\"img/lics16-slides.png\" alt=\"LICS16 Slides\"><br>\n      Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Compositional Recurrence Analysis</span>\n     with <a href=\"http://www.cs.toronto.edu/~azadeh\">Azadeh Farzan</a>.  FMCAD 2015.\n      <div class=\"blurb\">\n\tThis paper presents a new method for automatically generating\n\tnumerical invariants for imperative programs. The procedure computes a\n\ttransition formula which over-approximates the behaviour of a given\n\tinput program.  It is compositional in the sense that it operates by\n\tdecomposing the program into parts, computing a transition formula for\n\teach part, and then composing them.  Transition formulas for loops are\n\tcomputed by extracting recurrence relations from a transition formula\n\tfor the loop body and then computing their closed forms.\n\tExperimentation demonstrates that this method is competitive with\n\tleading verification techniques.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/fmcad15.pdf\">\n      <img src=\"img/fmcad15.png\" alt=\"FMCAD15 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/fmcad15-slides.pdf\">\n      <img src=\"img/fmcad15-slides.png\" alt=\"FMCAD15 Slides\">\n      <br>Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Spatial Interpolants</span>\n      with <a href=\"http://pages.cs.wisc.edu/~aws\">Aws Albarghouthi</a>,\n       <a href=\"http://research.microsoft.com/en-us/people/jjb\">Josh Berdine</a>, and\n       <a href=\"http://www0.cs.ucl.ac.uk/staff/b.cook/\">Byron Cook</a>.\n       ESOP 2015.\n     <div class=\"blurb\">\n       We propose SplInter, a new technique for proving properties of\n       heap-manipulating programs that marries (1) a new <i>separation\n       logic-based</i> analysis for heap reasoning with (2) an\n       <i>interpolation-based</i> technique for refining heap-shape invariants\n       with data invariants.  SplInter is <i>property\n       directed</i>, <i>precise</i>, and produces counterexample traces when a\n       property does not hold.  Using the novel notion of <i>spatial\n       interpolants modulo theories</i>, SplInter can infer complex invariants\n       over general recursive predicates, e.g., of the form \"all elements in\n       a linked list are even\" or \"a binary tree is sorted.\"\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/esop15.pdf\">\n      <img src=\"img/esop15.png\" alt=\"ESOP15 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Proof Spaces for Unbounded Parallelism</span>\n     with <a href=\"http://www.cs.toronto.edu/~azadeh\">Azadeh Farzan</a> and <a href=\"http://swt.informatik.uni-freiburg.de/staff/podelski\">Andreas Podelski</a>.\n     POPL 2015.\n     <div class=\"blurb\">\n       In this paper, we describe proof spaces, a proof system for verifying\n       safety properties for multi-threaded programs in which the number of\n       executing threads is not statically bounded.  Our development of this\n       proof system is motivated by the question of how to generalize a proof\n       of correctness (perhaps obtained from a verifier for sequential\n       programs) of a some finite set of example traces so that the\n       correctness argument applies to all traces of the program.  We show\n       that proof spaces are complete relative to the inductive assertion\n       method, and give algorithms for automating them.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl15.pdf\">\n      <img src=\"img/popl15.png\" alt=\"POPL15 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl15-slides.pdf\">\n      <img src=\"img/popl15-slides.png\" alt=\"POPL15 Slides\">\n      <br>Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Consistency Analysis of Decision-Making Programs</span>\n     with <a href=\"http://www.cs.rice.edu/~sc40/\">Swarat Chaudhuri</a>\n      and <a href=\"http://www.cs.toronto.edu/~azadeh\">Azadeh Farzan</a>.\n     POPL 2014.\n     <div class=\"blurb\">\n       Applications in many areas of computing make discrete decisions under\n       <i>uncertainty</i>; for example, the application may rely on limited\n       numerical precision in input, or on input or sensory data.  While an\n       application executing under uncertainty cannot be relied upon to make\n       decisions which are correct with respect to a given world, it is\n       desirable that their decisions are at least <i>consistent</i> (i.e.,\n       correct with respect to <i>some</i> possible world).  This paper\n       presents a sound, automatic program analysis for verifying program\n       consistency.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl14a.pdf\">\n      <img src=\"img/popl14a.png\" alt=\"POPL14a PDF\"><br>\n      PDF\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Proofs that count</span>\n     with <a href=\"http://www.cs.toronto.edu/~azadeh\">Azadeh Farzan</a> and <a href=\"http://swt.informatik.uni-freiburg.de/staff/podelski\">Andreas Podelski</a>.\n     POPL 2014.\n     <div class=\"blurb\">\n       Counting arguments are among the most basic methods of proof in\n       mathematics.  Within the field of formal verification, they are useful\n       for reasoning about programs with <i>infinite control</i>, such as\n       programs with an unbounded number of threads, or (concurrent) programs\n       with recursive procedures.  While counting arguments are common in\n       informal, hand-written proofs of such programs, there are no fully\n       <i>automated</i> techniques to construct counting arguments.  The key\n       questions involved in automating counting arguments are: <i>how to\n       decide what should be counted?</i>, and <i>how to decide when a\n       counting argument is valid?</i>  In this paper, we present a technique\n       for automatically constructing and checking counting arguments, which\n       includes novel solutions to these questions.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl14b.pdf\">\n      <img src=\"img/popl14b.png\" alt=\"POPL14b PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl14b-slides.pdf\">\n      <img src=\"img/popl14b-slides.png\" alt=\"POPL14b Slides\">\n      <br>Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Symbolic Optimization with SMT solvers</span>\n     with \n      <a href=\"http://www.cs.toronto.edu/~liyi/host/Home.html\">Yi Li</a>,\n      <a href=\"http://pages.cs.wisc.edu/~aws\">Aws Albarghouthi</a>,\n      <a href=\"http://www.sei.cmu.edu/about/people/profile.cfm?id=gurfinkel_14336\">Arie Gurfinkel</a>\n      and <a href=\"http://www.cs.toronto.edu/~chechik/\">Marsha Chechik</a>.\n     POPL 2014.\n     <div class=\"blurb\">\n       The rise in efficiency of Satisfiability Modulo Theories (SMT) solvers\n       has created numerous uses for them in programming languages: software\n       verification, program synthesis, functional programming, refinement\n       types, etc.  SMT solvers are effective at finding arbitrary satisfying\n       assignments for formulae, but for some applications it is necessary to\n       find an assignment that optimizes (minimizes/maximizes) certain\n       criteria.  We present an efficient SMT-based optimization algorithm for\n       objective functions in the theory of linear real arithmetic.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl14c.pdf\">\n      <img src=\"img/popl14c.png\" alt=\"POPL14c PDF\"><br>\n      PDF\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Duet: static analysis for unbounded parallelism</span>\n     with <a href=\"http://www.cs.toronto.edu/~azadeh\">Azadeh Farzan</a>.\n     CAV 2013.\n     <div class=\"blurb\">\n       <a href=\"http://duet.cs.toronto.edu\">Duet</a> is a static analysis tool\n       for concurrent programs in which the number of executing threads is not\n       statically bounded.  It has a modular architecture, which is based on\n       separating the invariant synthesis problem in two subtasks: (1) data\n       dependence analysis, which is used to construct a data flow model of\n       the program, and (2) interpretation of the data flow model over a\n       (possibly infinite) abstract domain, which generates invariants.  This\n       separation of concerns allows researchers working on data dependence\n       analysis and abstract domains to combine their efforts toward solving\n       the challenging problem of static analysis for unbounded concurrency.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/cav13b.pdf\">\n      <img src=\"img/cav13b.png\" alt=\"CAV13b PDF\"><br>\n      PDF\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Recursive program synthesis</span>\n     with <a href=\"http://pages.cs.wisc.edu/~aws\">Aws Albargouthi</a> and <a href=\"http://research.microsoft.com/en-us/um/people/sumitg\">Sumit Gulwani</a>.\n     CAV 2013.\n     <div class=\"blurb\">\n       Program synthesis from input-output examples has the power of extending\n       the range of computational tasks achievable by end-users who have no\n       programming knowledge, but can articulate their desired computations by\n       describing input-output behaviour.  In this paper we present Escher, an\n       algorithm that interacts with the user via input-output examples to\n       synthesize recursive programs.  Escher is parameterized by the\n       components that can be used in the program, thus providing a generic\n       synthesis algorithm that can be instantiated to suit different domains.\n       Escher adopts a novel search strategy through the space of programs\n       that utilizes special datastructures for inferring conditionals and\n       synthesizing recursive procedures.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/cav13a.pdf\">\n      <img src=\"img/cav13a.png\" alt=\"CAV2013a PDF\"><br>\n      PDF\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Inductive data flow graphs</span>\n     with <a href=\"http://www.cs.toronto.edu/~azadeh\">Azadeh Farzan</a> and <a href=\"http://swt.informatik.uni-freiburg.de/staff/podelski\">Andreas Podelski</a>.\n     POPL 2013.\n     <div class=\"blurb\">\n       We propose inductive data flow graphs, data flow graphs with\n       incorporated inductive assertions, as the basis of an approach to\n       verifying concurrent programs. An inductive data flow graph accounts\n       for a set of dependencies between program events, and therefore stands\n       as a representation for the set of executions which give rise to these\n       dependencies.  By representing information about dependencies rather\n       than control flow, inductive data flow graphs can yield very succinct\n       proofs.  Our strategy for verifying concurrent programs defers\n       reasoning about control to the proof checking step, a purely\n       combinatorial problem, thus avoiding the need to reason about data and\n       control simultaneously.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl13.pdf\">\n      <img src=\"img/popl13.png\" alt=\"POPL13 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl13-slides.pdf\">\n      <img src=\"img/popl13-slides.png\" alt=\"POPL13 Slides\">\n      <br>Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Verification of parameterized concurrent programs by modular reasoning about data and control</span>\n     with <a href=\"http://www.cs.toronto.edu/~azadeh\">Azadeh Farzan</a>.\n     POPL 2012.\n     <div class=\"blurb\">\n       We consider the problem of verifying thread-state properties of\n       multithreaded programs in which the number of active threads cannot be\n       statically bounded.  Our approach is based on decomposing the task into\n       two modules, where one reasons about data and the other reasons about\n       control.  The two modules are incorporated into a feedback loop, so\n       that the abstractions of data and control are iteratively coarsened as\n       the algorithm progresses (that is, they become weaker) until a fixed\n       point is reached.<br>\n\n       <span style=\"color:#005090\">This version fixes some typographical\n       errors that appeared in the printed version - thanks to Chinmay\n       Narayan, Suvam Mukherjee, and Deepak D'Souza for finding them.</span>\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl12.pdf\">\n      <img src=\"img/popl12.png\" alt=\"POPL12 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/popl12-slides.pdf\">\n      <img src=\"img/popl12-slides.png\" alt=\"POPL12 Slides\">\n      <br>Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n   <br>\n   <table class=\"paper\">\n    <tbody><tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Compositional bitvector analysis for concurrent programs with nested locks</span><br>\n     with <a href=\"http://www.cs.toronto.edu/~azadeh\">Azadeh Farzan</a>.\n     SAS 2010.\n     <div class=\"blurb\">\n       We propose a new technique for bitvector data flow analysis for\n       concurrent programs. Our algorithm works for concurrent programs that\n       synchronize via nested locks.  We give a compositional algorithm that\n       first computes thread summaries and then efficiently combines them to\n       solve the dataflow analysis problem.  We show that this algorithm\n       computes precise solutions (meet over all paths) to bitvector problems.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/sas10.pdf\">\n      <img src=\"img/sas10.png\" alt=\"SAS10 PDF\"><br>\n      PDF\n     </a>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/sas10-slides.pdf\">\n      <img src=\"img/sas10-slides.png\" alt=\"SAS10 Slides\">\n      <br>Slides\n     </a>\n    </td>\n    </tr>\n   </tbody></table>\n\n<!--   \n   <br />\n   <table class=\"paper\">\n    <tr>\n    <td style=\"width:100%\">\n      <span class=\"title\">Duplication in DNA sequences</span>\n     with Masami Ito, <a href=\"http://www.cs.uwo.ca/~lila\">Lila Kari</a>, and <a href=\"http://kjk.office.uec.ac.jp/Profiles/69/0006845/prof_e.html\">Shinnosuke Seki</a>.\n     DLT 2008.\n     <div class=\"blurb\">\n       The duplication and repeat-deletion operations are the basis of a\n       formal language theoretic model of errors that can occur during DNA\n       replication. During DNA replication, subsequences of a strand of DNA\n       may be copied several times (resulting in duplications) or skipped\n       (resulting in repeat-deletions). In this paper, we investigate several\n       properties of these operations, including closure properties of\n       language families in the Chomsky hierarchy, equations involving these\n       operations, and steps towards a characterization of regular duplication\n       languages, i.e. languages that are the result of the duplication\n       operation applied to a given set.\n     </div>\n    </td>\n    <td align=\"center\">\n     <a href=\"pub/dlt08.pdf\">\n      <img src=\"img/dlt08.png\" alt=\"DLT2008 PDF\"/><br />\n      PDF\n     </a>\n    </td>\n    </tr>\n   </table>\n-->\n\n<h1><a name=\"teaching\">teaching</a></h1>\nSpring 2019 - <a href=\"http://www.cs.princeton.edu/courses/archive/spring19/cos320/\">COS 320: Compiling techniques</a>\n\n<br>\nPast:\n<ul>\n  <li>\n    Fall 2018 - <a href=\"courses/fall18/\">COS 516 / ELE 516: Automated Reasoning about Software</a>\n  </li>\n  <li>\n    Spring 2018 - <a href=\"courses/spring18/iw06\">COS IW 06: Little\n    Languages</a> and\n    <a href=\"courses/spring18/iw07\">COS IW 07: Practical Solutions to Intractable Problems</a>\n  </li>\n  <li>\n    Spring 2017 - <a href=\"http://www.cs.princeton.edu/courses/archive/spring17/cosIW08/\">COS IW 08: Practical solutions to intractable problems</a>.\n  </li>\n  <li>\n    Fall 2016 - <a href=\"courses/fall16/\">COS 597D: Reasoning about concurrent systems</a>.\n  </li>\n  </ul>\n\n   <h1><a name=\"students\">students</a></h1>\n   <ul>\n     <li>\n       <a href=\"http://www.cs.princeton.edu/~tcm3/\">Charlie Murphy</a>\n     </li>\n     <li>\n       <a href=\"https://www.cs.princeton.edu/~jakers/\">Jake Silverman</a>\n     </li>\n     <li>\n       <a href=\"https://www.cs.princeton.edu/~shaoweiz/\">Shaowei Zhu</a>\n     </li>\n   </ul>\n\n   <h1><a name=\"activities\">activities</a></h1>\n   <ul>\n     <li>\n       CAV 2020: Program Committee.\n     </li>\n     <li>\n       PLDI 2020: External Review Committee.\n     </li>\n     <li>\n       POPL 2019-2020:  Workshop co-chair.\n     </li>\n     <li>\n       OBT 2018:  Program Committee.\n     </li>\n     <li>\n       CAV 2018:  Program Committee.\n     </li>\n     <li>\n       VSTTE 2017:  Program Committee.\n     </li>\n     <li>\n       CAV 2017:  Program Committee.\n     </li>\n     <li>\n       PLDI 2017:  Program Committee.\n     </li>\n     <li>\n       POPL 2017:  Program Committee.\n     </li>\n     <li>\n       CAV 2016:  Workshop chair/Program Committee.\n     </li>\n     <li>\n       PLDI 2016: External Review Committee.\n     </li>\n     <li>\n       TACAS 2016: Program Committee.\n     </li>\n     <li>\n       SSS 2015: Program Committee\n     </li>\n     <li>\n       Tiny Transactions on Computer Science vol. 3.:  Program Committee\n     </li>\n     <li>\n       PLDI 2014: Artifact Evaluation Committee\n     </li>\n   </ul>\n\n   <h1><a name=\"misc\">the rest</a></h1>\n   <ul>\n     <li> Slides for POPL'18 tutorial on algebraic program analysis:<br>\n       <a href=\"popl18-tutorial/background.pdf\">background</a> |\n       <a href=\"popl18-tutorial/intraproc.pdf\">intraprocedural analysis</a> |\n       <a href=\"http://www.cs.wisc.edu/wpis/talks/POPL18Tutorial-InterproceduralAnalysis.pptx\">interprocedural analysis</a> |\n       <a href=\"popl18-tutorial/NPATPGJ.pdf\">iteration domains</a>\n     </li>\n   <li> I received my PhD from the <a href=\"http://web.cs.toronto.edu/\">University of Toronto</a>.  My adviser was <a href=\"http://www.cs.toronto.edu/~azadeh/\">Azadeh Farzan</a>. </li>\n   <li> Some of my work is implemented in the <a href=\"http://duet.cs.toronto.edu\">Duet</a> program analyzer. </li>\n    <li>My <a href=\"http://en.wikipedia.org/wiki/Erd%C5%91s_number\">Erd\u0151s number</a> is <a href=\"http://www.ams.org/mathscinet/collaborationDistance.html?AuthorSourceName=Kincaid,%20Zachary&amp;AuthorTargetName=Erdos,%20Paul%201\">3</a>.</li>\n    <li><a href=\"http://www.cse.iitd.ernet.in/~chinmay/\">Chinmay Narayan</a>\n    has typeset a <a href=\"pub/popl12faq.pdf\">FAQ</a> for our POPL12\n    paper.</li>\n   </ul>\n  </div>\n \n\n</body></html>"