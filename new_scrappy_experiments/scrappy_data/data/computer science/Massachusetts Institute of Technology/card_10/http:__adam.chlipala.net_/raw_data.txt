{"email": ["adamc@csail.mit.edu"], "image": ["adamc2019.jpg", "fscq.png", "https://www.eecs.mit.edu/people/web.png", "https://www.eecs.mit.edu/people/ltamer.png", "cpdt.jpg"], "research_blurb": ["I'm in a transitional period, in terms of simple descriptions of my research interests.  My traditional areas are , but my interests have broadened to include other aspects of computer-system design and implementation.  I like the idea of doing clean-slate redesign of computing stacks with current security and privacy concerns front-and-center, which I do believe involves, in a central way, my traditional focus of I try to organize my research group as something like a startup company looking to produce one convincing unified demo of a clean-slate-ish full-stack, practical computer system.  (Like startup companies, we expect to pivot often based on what we learn!)  We are looking at simple embedded applications now, where the scope of machine-checked proofs and unified interface redesign reaches from  to relational specifications of network protocols.  I'm interested in recruiting students to contribute.  I do sometimes hire postdocs, though most of my recruiting strategy is centered on students (PhD, master's, undergrad).  Ideal candidates have strong backgrounds in both rigorous mathematical reasoning and software/hardware systems implementation.  There tends to be a bad match with students who use the word \"theory\" to describe their interests within programming languages or formal methods, to the point where our PhD program generally won't admit those people (they'd be better-served elsewhere!).  Current MIT students interested in working together should e-mail me, while for others I suggest following our normal PhD application process.For a bit more info on what I work on, two low-time-investment overviews (of the mechanized-proofs part) are ", "<table>\n<tbody><tr>\n<td>needs logo</td>\n<td class=\"project\"><i>Unnamed (and somewhat incipient) umbrella project to build demonstration software/hardware systems with end-to-end mechanized proofs.</i>  I started my time as faculty developing the <a href=\"https://github.com/mit-plv/bedrock\">Bedrock</a> library for verified multilanguage programming, but that project is largely over; we are working on a replacement project now that shares the name but makes very different design decisions, still supporting separation-logic-verified low-level programs (in a tasteful language, not C!) processed by a verified compiler, which I would like to use to explore alternative and drastically simplified OS-like functionality.  The programming layer on top is meant to involve our <a href=\"https://github.com/mit-plv/fiat\">Fiat</a> system for automatic and correct-by-construction program derivation from specifications, which we are currently experimenting with using to generate code for practical network servers, a convenient domain for trying to make high-level programming more like relational-database programming but without the usual rough edges.  Beneath the level of assembly language, we have work in the <a href=\"https://github.com/mit-plv/kami\">Kami</a> project on modular hardware verification and verified compilation, where development is proceeding now jointly with industry, and where I'm especially interested in exploring alternative concurrency support in general-purpose processors.  One of the cross-cutting focuses now is cryptography, including in our <a href=\"https://github.com/mit-plv/fiat-crypto\">Fiat Cryptography</a> project that centers on what is essentially a verified domain-specific compiler for finite-field arithmetic, which should soon be included in the build process for Google Chrome (to produce some of the code to validate SSL connections).</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"http://css.csail.mit.edu/fscq/\"><img class=\"project\" height=\"95\" src=\"fscq.png\" width=\"125\"/></a></td>\n<td class=\"project\"><a href=\"http://css.csail.mit.edu/fscq/\">FSCQ</a>, a file system verified in Coq using a separation logic for reasoning about crash safety, mostly carried out these days by colleagues in <a href=\"https://pdos.csail.mit.edu/\">the PDOS group</a></td>\n</tr>\n<tr>\n<td><a href=\"http://deepspec.org\"><img alt=\"DeepSpec\" class=\"project\" src=\"http://deepspec.org/img/deepspec-logo-300dpi.png\" width=\"120\"/></a></td>\n<td class=\"project\"><a href=\"http://deepspec.org/\"><strong>The Science of Deep Specification</strong></a>, a National Science Foundation Expedition in Computing, 2016-2021, promoting similar full-stack-verification research to what I described above, but on more conventional architectures</td>\n</tr>\n</tbody></table>", "<table>\n<tbody><tr>\n<td><a href=\"http://www.impredicative.com/ur/\"><img class=\"project\" height=\"99\" src=\"web.png\" width=\"127\"/></a></td>\n<td class=\"project\"><a href=\"http://www.impredicative.com/ur/\">Ur/Web</a>, a domain-specific functional programming language for modern Web applications.  I started working on it when I was a grad student, and it's pretty much done research-wise, yielding a production-quality tool suite that a fair number of people enjoy using.</td>\n</tr>\n<tr>\n<td><a href=\"http://ltamer.sf.net/\"><img class=\"project\" height=\"131\" src=\"ltamer.png\" width=\"192\"/></a></td>\n<td class=\"project\"><a href=\"http://ltamer.sf.net/\">Lambda Tamer</a>, an umbrella library for the experiments in compiler verification that I started as a grad student.  The most concrete outcome of the work was the <a href=\"papers/PhoasICFP08/\">parametric higher-order abstract syntax (PHOAS)</a> encoding of program syntax, which we still put to use in many of my projects, where different kinds of compilers remain frequent ingredients in novel system designs.</td>\n</tr>\n</tbody></table>", "<!--h3>Postdocs</h3>\n\n      <ul>\n\n      </ul-->", "(An \"*\" indicates a class I [co]created.)", "Certified Programming with Dependent Types: A Pragmatic Introduction to the Coq Proof Assistant", " committee now, to help us get this excessive conference-going under control.  (I'm in favor of one conference per research area per year, with as many parallel tracks as needed!)"]}